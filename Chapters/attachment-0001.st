'From Squeak5.3beta of 26 December 2019 [latest update: #19295] on 10 January 2020 at 1:53:55 pm'!Mutex subclass: #Monitor	instanceVariableNames: 'defaultQueue queueDict queuesMutex nestingLevel'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Monitor commentStamp: 'eem 1/7/2016 11:38' prior: 0!A monitor provides process synchronization that is more high level than the one provided by a Semaphore. Similar to the classical definition of a Monitor it has the following properties:1) At any time, only one process can execute code inside a critical section of a monitor.2) A monitor is reentrant, which means that the active process in a monitor never gets blocked when it enters a (nested) critical section of the same monitor.  For example a monitor will not block when trying the following:		| m |		m := Monitor new.		m critical: [m critical: [#yes]]	whereas a Semaphore will deadlock:		| s |		s := Semaphore forMutualExclusion.		s critical: [s critical: [#no]]3) Inside a critical section, a process can wait for an event that may be coupled to a certain condition. If the condition is not fulfilled, the process leaves the monitor temporarily (in order to let other processes enter) and waits until another process signals the event. Then, the original process checks the condition again (this is often necessary because the state of the monitor could have changed in the meantime) and continues if it is fulfilled.4) The monitor is fair, which means that the process that is waiting on a signaled condition the longest gets activated first.5) The monitor allows you to define timeouts after which a process gets activated automatically.Basic usage:Monitor>>critical: aBlockCritical section.Executes aBlock as a critical section. At any time, only one process can execute code in a critical section.NOTE: All the following synchronization operations are only valid inside the critical section of the monitor!!Monitor>>waitUnconditional waiting for the default event.The current process gets blocked and leaves the monitor, which means that the monitor allows another process to execute critical code. When the default event is signaled, the original process is resumed.Monitor>>waitWhile: aBlockConditional waiting for the default event.The current process gets blocked and leaves the monitor only if the argument block evaluates to true. This means that another process can enter the monitor. When the default event is signaled, the original process is resumed, which means that the condition (argument block) is checked again. Only if it evaluates to false, does execution proceed. Otherwise, the process gets blocked and leaves the monitor again...Monitor>>waitUntil: aBlockConditional waiting for the default event.See Monitor>>waitWhile: aBlock.Monitor>>signalOne process waiting for the default event is woken up.Monitor>>signalAllAll processes waiting for the default event are woken up.Using non-default (specific) events:Monitor>>waitFor: aSymbolUnconditional waiting for the non-default event represented by the argument symbol.Same as Monitor>>wait, but the process gets only reactivated by the specific event and not the default event.Monitor>>waitWhile: aBlock for: aSymbolConfitional waiting for the non-default event represented by the argument symbol.Same as Monitor>>waitWhile:for:, but the process gets only reactivated by the specific event and not the default event.Monitor>>waitUntil: aBlock for: aSymbolConfitional waiting for the non-default event represented by the argument symbol.See Monitor>>waitWhile:for: aBlock.Monitor>>signal: aSymbolOne process waiting for the given event is woken up. If there is no process waiting for this specific event, a process waiting for the default event gets resumed.Monitor>>signalAll: aSymbolAll process waiting for the given event or the default event are woken up.Monitor>>signalReallyAllAll processes waiting for any events (default or specific) are woken up.Using timeoutsMonitor>>waitMaxMilliseconds: anIntegerMonitor>>waitFor: aSymbol maxMilliseconds: anIntegerSame as Monitor>>wait (resp. Monitor>>waitFor:), but the process gets automatically woken up when the specified time has passed.Monitor>>waitWhile: aBlock maxMilliseconds: anIntegerMonitor>>waitWhile: aBlock for: aSymbol maxMilliseconds: anIntegerSame as Monitor>>waitWhile: (resp. Monitor>>waitWhile:for:), but the process gets automatically woken up when the specified time has passed.Monitor>>waitUntil: aBlock maxMilliseconds: anIntegerMonitor>>waitUntil: aBlock for: aSymbol maxMilliseconds: anIntegerSame as Monitor>>waitUntil: (resp. Monitor>>waitUntil:for:), but the process gets automatically woken up when the specified time has passed.!!Monitor methodsFor: 'accessing' stamp: 'NS 7/1/2002 20:02'!cleanup	self checkOwnerProcess.	self critical: [self privateCleanup].! !!Monitor methodsFor: 'initialize-release' stamp: 'ul 2/5/2018 20:25'!initialize	queuesMutex := Mutex new! !!Monitor methodsFor: 'signaling-default' stamp: 'NS 7/1/2002 21:57'!signal	"One process waiting for the default event is woken up."	^ self signal: nil! !!Monitor methodsFor: 'signaling-default' stamp: 'NS 7/1/2002 21:57'!signalAll	"All processes waiting for the default event are woken up."	^ self signalAll: nil! !!Monitor methodsFor: 'signaling-specific' stamp: 'NS 4/13/2004 15:12'!signal: aSymbolOrNil	"One process waiting for the given event is woken up. If there is no process waiting 	for this specific event, a process waiting for the default event gets resumed."	| queue |	self checkOwnerProcess.	queue := self queueFor: aSymbolOrNil.	queue isEmpty ifTrue: [queue := self defaultQueue].	self signalQueue: queue.! !!Monitor methodsFor: 'signaling-specific' stamp: 'NS 7/1/2002 22:02'!signalAll: aSymbolOrNil	"All process waiting for the given event or the default event are woken up."	| queue |	self checkOwnerProcess.	queue := self queueFor: aSymbolOrNil.	self signalAllInQueue: self defaultQueue.	queue ~~ self defaultQueue ifTrue: [self signalAllInQueue: queue].! !!Monitor methodsFor: 'signaling-specific' stamp: 'NS 7/1/2002 22:02'!signalReallyAll	"All processes waiting for any events (default or specific) are woken up."	self checkOwnerProcess.	self signalAll.	self queueDict valuesDo: [:queue |		self signalAllInQueue: queue].! !!Monitor methodsFor: 'waiting-basic' stamp: 'NS 7/1/2002 21:55'!wait	"Unconditional waiting for the default event.	The current process gets blocked and leaves the monitor, which means that the monitor	allows another process to execute critical code. When the default event is signaled, the	original process is resumed."	^ self waitMaxMilliseconds: nil! !!Monitor methodsFor: 'waiting-basic' stamp: 'NS 7/1/2002 21:56'!waitUntil: aBlock	"Conditional waiting for the default event.	See Monitor>>waitWhile: aBlock."	^ self waitUntil: aBlock for: nil! !!Monitor methodsFor: 'waiting-basic' stamp: 'fbs 3/24/2004 14:39'!waitWhile: aBlock	"Conditional waiting for the default event.	The current process gets blocked and leaves the monitor only if the argument block	evaluates to true. This means that another process can enter the monitor. When the 	default event is signaled, the original process is resumed, which means that the condition	(argument block) is checked again. Only if it evaluates to false, does execution proceed.	Otherwise, the process gets blocked and leaves the monitor again..."	^ self waitWhile: aBlock for: nil! !!Monitor methodsFor: 'waiting-specific' stamp: 'NS 7/1/2002 21:58'!waitFor: aSymbolOrNil	"Unconditional waiting for the non-default event represented by the argument symbol.	Same as Monitor>>wait, but the process gets only reactivated by the specific event and 	not the default event."	^ self waitFor: aSymbolOrNil maxMilliseconds: nil! !!Monitor methodsFor: 'waiting-specific' stamp: 'NS 7/1/2002 22:01'!waitUntil: aBlock for: aSymbolOrNil	"Confitional waiting for the non-default event represented by the argument symbol.	See Monitor>>waitWhile:for: aBlock."	^ self waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: nil! !!Monitor methodsFor: 'waiting-specific' stamp: 'NS 7/1/2002 22:01'!waitWhile: aBlock for: aSymbolOrNil	"Confitional waiting for the non-default event represented by the argument symbol.	Same as Monitor>>waitWhile:for:, but the process gets only reactivated by the specific 	event and not the default event."	^ self waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: nil! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:03'!waitFor: aSymbolOrNil maxMilliseconds: anIntegerOrNil	"Same as Monitor>>waitFor:, but the process gets automatically woken up when the 	specified time has passed."	self checkOwnerProcess.	self waitInQueue: (self queueFor: aSymbolOrNil) maxMilliseconds: anIntegerOrNil.! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:04'!waitFor: aSymbolOrNil maxSeconds: aNumber	"Same as Monitor>>waitFor:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitFor: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:04'!waitMaxMilliseconds: anIntegerOrNil	"Same as Monitor>>wait, but the process gets automatically woken up when the 	specified time has passed."	^ self waitFor: nil maxMilliseconds: anIntegerOrNil! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:05'!waitMaxSeconds: aNumber	"Same as Monitor>>wait, but the process gets automatically woken up when the 	specified time has passed."	^ self waitMaxMilliseconds: (aNumber * 1000) asInteger! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:05'!waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil	"Same as Monitor>>waitUntil:for:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitWhile: [aBlock value not] for: aSymbolOrNil maxMilliseconds: anIntegerOrNil! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:05'!waitUntil: aBlock for: aSymbolOrNil maxSeconds: aNumber	"Same as Monitor>>waitUntil:for:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:05'!waitUntil: aBlock maxMilliseconds: anIntegerOrNil	"Same as Monitor>>waitUntil:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitUntil: aBlock for: nil maxMilliseconds: anIntegerOrNil! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:06'!waitUntil: aBlock maxSeconds: aNumber	"Same as Monitor>>waitUntil:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitUntil: aBlock maxMilliseconds: (aNumber * 1000) asInteger! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:06'!waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil	"Same as Monitor>>waitWhile:for:, but the process gets automatically woken up when the 	specified time has passed."	self checkOwnerProcess.	self waitWhile: aBlock inQueue: (self queueFor: aSymbolOrNil) maxMilliseconds: anIntegerOrNil.! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:06'!waitWhile: aBlock for: aSymbolOrNil maxSeconds: aNumber	"Same as Monitor>>waitWhile:for:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:06'!waitWhile: aBlock maxMilliseconds: anIntegerOrNil	"Same as Monitor>>waitWhile:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitWhile: aBlock for: nil maxMilliseconds: anIntegerOrNil! !!Monitor methodsFor: 'waiting-timeout' stamp: 'NS 7/1/2002 22:06'!waitWhile: aBlock maxSeconds: aNumber	"Same as Monitor>>waitWhile:, but the process gets automatically woken up when the 	specified time has passed."	^ self waitWhile: aBlock maxMilliseconds: (aNumber * 1000) asInteger! !!Monitor methodsFor: 'private' stamp: 'ul 3/5/2018 20:46'!checkOwnerProcess	"If the receiver is not already the owner of the section raise an error."		self primitiveTestAndSetOwnershipOfCriticalSection ifNotNil: [ :alreadyOwner |		alreadyOwner ifTrue: [ ^self ].		self primitiveExitCriticalSection ].	self error: 'Monitor access violation'! !!Monitor methodsFor: 'private' stamp: 'NS 7/1/2002 15:06'!defaultQueue	defaultQueue ifNil: [defaultQueue := OrderedCollection new].	^ defaultQueue! !!Monitor methodsFor: 'private' stamp: 'eem 1/5/2016 09:42'!exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil	[ | lock |	 lock := queuesMutex critical: [ anOrderedCollection addLast: Semaphore new ].	 self primitiveExitCriticalSection.	 anIntegerOrNil 		ifNil: [ lock wait 	]		ifNotNil:			[ | delay |			 delay := MonitorDelay 				signalLock: lock				afterMSecs: anIntegerOrNil				inMonitor: self				queue: anOrderedCollection.			 [ lock wait ] ensure: [ delay unschedule ] ] ]		ensure: [ self primitiveEnterCriticalSection ]! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:14'!privateCleanup	queuesMutex critical: [		defaultQueue isEmpty ifTrue: [defaultQueue := nil].		queueDict ifNotNil: [			queueDict copy keysAndValuesDo: [:id :queue | 				queue isEmpty ifTrue: [queueDict removeKey: id]].			queueDict isEmpty ifTrue: [queueDict := nil].		].	].! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 02:13'!queueDict		^queueDict ifNil: [ queueDict := IdentityDictionary new ]! !!Monitor methodsFor: 'private' stamp: 'nice 1/2/2013 23:15'!queueFor: aSymbol	aSymbol ifNil: [^ self defaultQueue].	^ self queueDict 		at: aSymbol 		ifAbsentPut: [OrderedCollection new].! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 03:40'!signalAllInQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection removeAllSuchThat: [ :each |			each signal.			true ] ]! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:34'!signalLock: aSemaphore inQueue: anOrderedCollection	queuesMutex critical: [		aSemaphore signal.		anOrderedCollection remove: aSemaphore ifAbsent: [].	].! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 03:41'!signalQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection isEmpty ifFalse: [			anOrderedCollection removeFirst signal ] ]! !!Monitor methodsFor: 'private' stamp: 'NS 7/1/2002 13:17'!waitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil	self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil.! !!Monitor methodsFor: 'private' stamp: 'NS 7/1/2002 13:17'!waitWhile: aBlock inQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil	[aBlock value] whileTrue: [self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil].! !